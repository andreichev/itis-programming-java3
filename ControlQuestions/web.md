[Вопросы для собеседования](README.md)

# Основы Web
+ [Что такое клиент-сервер?](#что-такое-клиент-сервер?)
+ [Что такое веб-сервисы, какие у них есть протоколы?](#что-такое-веб-сервисы,-какие-у-них-есть-протоколы?)
+ [Что такое _WWW_?](#что-такое-www)
+ [Что такое _W3C_?](#что-такое-w3c)
+ [Какие существуют уровни модели _OSI_?](#какие-существуют-уровни-модели-osi)
+ [Что такое _TCP/IP_?](#что-такое-tcpip)
+ [Что такое _UDP_?](#что-такое-udp)
+ [Чем отличаются _TCP_ и _UDP_?](#чем-отличаются-tcp-и-udp)
+ [Что такое протокол передачи данных? Какие протоколы вы знаете?](#что-такое-протокол-передачи-данных-Какие-протоколы-вы-знаете)
+ [Что такое _HTTP_ и _HTTPS_? Чем они отличаются?](#что-такое-http-и-https-Чем-они-отличаются)
+ [Какие есть методы у HTTP?](#какие-есть-методы-у-HTTP?)
+ [Какие есть группы кодов ответы у HTTP?](#какие-есть-группы-кодов-ответы-у-HTTP?)
+ [Что такое _FTP_?](#что-такое-ftp)
+ [Что такое API?](#что-такое-API?)
+ [Чем отличаются методы _GET_ и _POST_?](#чем-отличаются-методы-get-и-post)
+ [Что такое DNS?](#что-такое-DNS?) 
+ [Что такое _MIME тип_?](#что-такое-mime-тип)
+ [Что такое _Web server_?](#что-такое-web-server)
+ [Что такое _Web application_?](#что-такое-web-application)
+ [Что такое _Application server_?](#что-такое-application-server)
+ [Чем отличаются _Web server_ и _Application server_?](#чем-отличаются-web-server-и-application-server)
+ [Что такое _AJAX_? Как принципиально устроена эта технология?](#что-такое-ajax-Как-принципиально-устроена-эта-технология)
+ [Что такое _WebSocket_?](#что-такое-websocket)
+ [Что такое _JSON_?](#что-такое-json)
+ [Что такое _JSON схема_?](#что-такое-json-схема)
+ [Что такое _cookies_?](#что-такое-cookies)
+ [Что такое _«сессия»_?](#что-такое-сессия)
+ [Что такое _«авторизация»_ и _«аутентификация»_? Чем они отличаются?](#что-такое-авторизация-и-аутентификация-Чем-они-отличаются)
+ [Требования к архитектуре REST?](#требования-к-архитектуре-REST)
+ [REST и SOAP - что это, в чем разница, какие у каждого плюсы и минусы?](#REST-и-SOAP-что-это,-в-чем-разница,-какие-у-каждого-плюсы-и-минусы?)
+ [Какие есть методы у REST?](#какие-есть-методы-у-REST?)
+ [Можем ли мы получить данные методом POST?](#можем-ли-мы-получить-данные-методом-POST?)
+ [Можем ли мы добавить данные методом GET?](#можем-ли-мы-добавить-данные-методом-GET?)
+ [Является ли метод POST защищенным?](#является-ли-метод-POST-защищенным?)
+ [Что такое микросервисы? Чем они отличаются от монолита?](#что-такое-микросервисы?-Чем-они-отличаются-от-монолита?)

## Что такое клиент-сервер?

«Клиент — сервер» (англ. client–server) — вычислительная или сетевая архитектура, в которой задания или сетевая нагрузка распределены между поставщиками услуг, называемыми серверами, и заказчиками услуг, называемыми клиентами. Фактически клиент и сервер — это программное обеспечение. Обычно эти программы расположены на разных вычислительных машинах и взаимодействуют между собой через вычислительную сеть посредством сетевых протоколов.
Программы-серверы ожидают от клиентских программ запросы и предоставляют им свои ресурсы в виде данных или в виде сервисных функций.

[к оглавлению](#основы-web)

##  Что такое веб-сервисы, какие у них есть протоколы?

Веб-страницы позволяют людям общаться и сотрудничать друг с другом.
Веб-службы позволяют программам общаться и сотрудничать друг с другом.
Веб-служба, веб-сервис (англ. web service) — идентифицируемая веб-адресом программная система со стандартизированными интерфейсами.
Веб-службы могут взаимодействовать друг с другом и со сторонними приложениями посредством сообщений, основанных на определённых протоколах (SOAP, XML-RPC и т. д.) и соглашениях (REST). Веб-служба является единицей модульности при использовании сервис-ориентированной архитектуры приложения.

То есть веб-служба - доступная через веб программная система со стандартизированным интерфейсом, предназначенная для взаимодействия с другими приложениями.

SOA — сервис-ориентированной архитектуры веб-приложений (Service Oriented Architecture) - модульного подхода к разработке программного обеспечения, основанного на использовании распределённых, слабо связанных(англ. loose coupling) заменяемых компонентов, оснащённых стандартизированными интерфейсами для взаимодействия по стандартизированным протоколам.
Программные комплексы, разработанные в соответствии с сервис-ориентированной архитектурой, обычно реализуются как набор веб-служб, взаимодействующих по протоколу SOAP, но существуют и другие реализации (например, на базе jini, CORBA, на основе REST).

SOAP: Протокол обмена сообщениями на базе XML;
WSDL: Язык описания внешних интерфейсов веб-службы на базе XML;
UDDI: Универсальный интерфейс распознавания, описания и интеграции (Universal Discovery, Description and Integration). Каталог веб-служб и сведений о компаниях, предоставляющих веб-службы во всеобщее пользование или конкретным компаниям. Пока UDDI существуют, однако, только в небольших фирменных сетях и ещё не нашли широкого распространения в открытом интернете.
REST (Representational State Transfer)
XML-RPC (XML Remote Procedure Call)

На самом деле, SOAP произошел от XML-RPC и является следующей ступенью его развития. В то время как REST — это концепция, в основе которой лежит скорее архитектурный стиль, нежели новая технология, основанный на теории манипуляции объектами CRUD (Create Read Update Delete) в контексте концепций WWW.

[к оглавлению](#основы-web)

## Что такое _WWW_?
__WWW, World Wide Web (Всемирная паутина)__ — распределённая система, предоставляющая доступ к связанным между собой документам, расположенным на различных компьютерах, подключённых к Интернету. Для обозначения этого термина также используют слово _web_.

[к оглавлению](#основы-web)

## Что такое _W3C_?
__W3C, World Wide Web Consortium (Консорциум Всемирной паутины)__ — организация, разрабатывающая и внедряющая технологические стандарты для WWW. 

W3C разрабатывает для Интернета единые принципы и стандарты, называемые _«рекомендациями» (W3C Recommendations)_, которые затем внедряются производителями программ и оборудования. Таким образом достигается совместимость между программными продуктами и аппаратурой различных компаний.

[к оглавлению](#основы-web)

## Какие существуют уровни модели _OSI_?
| # |                  Уровень (layer)                 |               Тип данных (PDU)            |                          Функции                         |          Примеры           |
|--:|--------------------------------------------------|:-----------------------------------------:|----------------------------------------------------------|:--------------------------:|
| 7 | Прикладной (application)                         |                      -                    | Доступ к сетевым службам                                 | HTTP, FTP                  |
| 6 | Представительский (представления) (presentation) |                      -                    | Представление и шифрование данных                        | ASCII, JPEG                |
| 5 | Сеансовый (session)                              |                      -                    | Управление сеансом связи                                 | RPC, PAP                   |
| 4 | Транспортный (transport)                         | Сегменты(segment) / Дейтаграммы(datagram) | Прямая связь между конечными пунктами и надежность       | TCP, UDP                   |
| 3 | Сетевой (network)                                |              Пакеты (packet)              | Определение маршрута и логическая адресация              | IP, AppleTalk              |
| 2 | Канальный (data link)                            |         Биты (bit) / Кадры (frame)        | Физическая адресация                                     | Ethernet, IEEE 802.2, L2TP |
| 1 | Физический (physical)                            |                  Биты (bit)               | Работа со средой передачи, сигналами и двоичными данными | USB, витая пара            |

[к оглавлению](#основы-web)

## Что такое _TCP/IP_?
__TCP/IP__ - это два основных сетевых протокола Internet. Часто это название используют и для обозначения сетей, работающих на их основе.

__IP (Internet Protocol)__ - маршрутизируемый протокол, отвечающий за IP-адресацию, маршрутизацию, фрагментацию и восстановление пакетов. В его задачу входит продвижение пакета между сетями – от одного маршрутизатора до другого и тех пор, пока пакет не попадет в сеть назначения. В отличие от протоколов прикладного и транспортного уровней, протокол IP разворачивается не только на хостах, но и на всех шлюзах (маршрутизаторах). Этот протокол работает без установления соединения и без гарантированной доставки.

В настоящее время используются следующие две версии протокола IP:

+ _IPv6_ — IP-адрес имеет разрядность 128 бит и записывается в виде восьми 16-битных полей, с использованием шестнадцатеричной системы счисления и с возможностью сокращения двух и более последовательных нулевых полей до `::`, например: `2001:db8:42::1337:cafe`
+ _IPv4_ — IP-адрес имеет разрядность 32 бита и записывается в виде четырех десятичных чисел в диапазоне 0 … 255 через точку, например: `192.0.2.34`.

__TCP (Transfer Control Protocol)__ - протокол, обеспечивающий надежную, требующую логического соединения связь между двумя компьютерами. Отвечает за установление соединения, упорядочивание посылаемых пакетов и восстановление пакетов, потерянных в процессе передачи.

Стек протоколов _TCP/IP_ включает в себя четыре уровня:

1. _канальный уровень (link layer)_ - например Ethernet, IEEE 802.11 Wireless Ethernet, физическая среда и принципы кодирования информации
2. _сетевой уровень (Internet layer)_ - например IP
3. _транспортный уровень (transport layer)_ - например TCP, UDP
4. _прикладной уровень (application layer)_ - например HTTP, FTP, DNS

TCP-соединение двух узлов начинается с _handshake (рукопожатия)_:

+ Узел _A_ посылает узлу _B_ специальный пакет `SYN` — приглашение к соединению
+ _B_ отвечает пакетом `SYN-ACK` — согласием об установлении соединения
+ _A_ посылает пакет `ACK` — подтверждение, что согласие получено

После этого _TCP соединение_ считается установленным и приложения, работающие в этих узлах, могут посылать друг другу пакеты с данными.

В заголовке _TCP/IP_ пакета указывается:

+ IP-адрес отправителя
+ IP-адрес получателя
+ Номер порта

[к оглавлению](#основы-web)

## Что такое _UDP_?
__UDP, User Datagram Protocol (Протокол пользовательских датаграмм)__ — протокол, который обеспечивает доставку без требований соединения с удаленным модулем UDP и обязательного подтверждения получения. 

К заголовку IP-пакета UDP добавляет всего четыре поля по 2 байта каждое:

1. _поле порта источника (source port)_
2. _поле порта пункта назначения (destination port)_
3. _поле длины (length)_
4. _поле контрольной суммы (checksum)_

Поля «порт источника» и «контрольная сумма» не являются обязательными для использования в IPv4. В IPv6 необязательно только поле «порт отправителя».

UDP используется _DNS_, _SNMP_, _DHCP_ и другими приложениями.

[к оглавлению](#основы-web)

## Чем отличаются _TCP_ и _UDP_?
__TCP__ — ориентированный на соединение протокол, что означает необходимость «рукопожатия» для установки соединения между двумя хостами. Как только соединение установлено, пользователи могут отправлять данные в обоих направлениях.

+ _Надёжность_ — TCP управляет подтверждением, повторной передачей и тайм-аутом сообщений. Производятся многочисленные попытки доставить сообщение. Если оно потеряется на пути, сервер вновь запросит потерянную часть. В TCP нет ни пропавших данных, ни (в случае многочисленных тайм-аутов) разорванных соединений.
+ _Упорядоченность_ — если два сообщения последовательно отправлены, первое сообщение достигнет приложения-получателя первым. Если участки данных приходят в неверном порядке, TCP отправляет неупорядоченные данные в буфер до тех пор, пока все данные не могут быть упорядочены и переданы приложению.
+ _Тяжеловесность_ — TCP необходимо три пакета для установки соединения перед тем, как отправить данные. TCP следит за надёжностью и перегрузками.
+ _Потоковость_ — данные читаются как поток байтов, не передается никаких особых обозначений для границ сообщения или сегментов.

__UDP__ — более простой, основанный на сообщениях протокол без установления соединения. Протоколы такого типа не устанавливают выделенного соединения между двумя хостами. Связь достигается путём передачи информации в одном направлении от источника к получателю без проверки готовности или состояния получателя.

+ _Ненадёжность_ — когда сообщение посылается, неизвестно, достигнет ли оно своего назначения — оно может потеряться по пути. Нет таких понятий как подтверждение, повторная передача, тайм-аут.
+ _Неупорядоченность_ — если два сообщения отправлены одному получателю, то порядок их достижения цели не может быть предугадан.
+ _Легковесность_ — никакого упорядочивания сообщений, никакого отслеживания соединений и т. д. Это лишь транспортный уровень.
+ _Датаграммы_ — пакеты посылаются по отдельности и проверяются на целостность только если они прибыли. Пакеты имеют определенные границы, которые соблюдаются после получения, то есть операция чтения на получателе выдаст сообщение таким, каким оно было изначально послано.
+ _Отсутствие контроля перегрузок_ — для приложений с большой пропускной способностью существует шанс вызвать коллапс перегрузок, если только они не реализуют меры контроля на прикладном уровне.

[к оглавлению](#основы-web)

## Что такое протокол передачи данных? Какие протоколы вы знаете?
__Протокол передачи данных__ — набор соглашений интерфейса логического уровня, которые определяют обмен данными между различными программами. Эти соглашения задают единообразный способ передачи сообщений и обработки ошибок при взаимодействии программного обеспечения разнесённой в пространстве аппаратуры, соединённой тем или иным интерфейсом.

Наиболее известные протоколы передачи данных:

+ HTTP (Hyper Text Transfer Protocol)
+ FTP (File Transfer Protocol)
+ POP3 (Post Office Protocol)
+ SMTP (Simple Mail Transfer Protocol)
+ TELNET (TErminaL NETwork)

[к оглавлению](#основы-web)

## Что такое _HTTP_ и _HTTPS_? Чем они отличаются?
__HTTP, HyperText Transfer Protocol (Протокол передачи гипертекста)__ — протокол прикладного уровня передачи данных. 

Основой HTTP является технология «клиент-сервер»:

+ _Потребители (клиенты)_, которые инициируют соединение и посылают запрос;
+ _Поставщики (серверы)_, которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.

Для идентификации ресурсов HTTP использует глобальные URI (это может быть не только файл на сервере, но, например, ISBN). 

HTTP не сохраняет своего состояния. Это означает отсутствие сохранения промежуточного состояния между парами «запрос-ответ».

Структура протокола:

1. _Стартовая строка (starting line)_ — определяет тип сообщения;
2. _Заголовки (headers)_ — характеризуют тело сообщения, параметры передачи и прочие сведения;
3. _Тело сообщения (message body)_ — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.

Заголовки и тело сообщения могут отсутствовать, но стартовая строка является обязательным элементом, так как указывает на тип запроса/ответа.

__HTTPS, HyperText Transfer Protocol Secure__ — расширение протокола HTTP, поддерживающее шифрование. 
Данные, передаваемые по протоколу HTTPS, «упаковываются» в криптографический протокол SSL или TLS, что обеспечивает защиту от атак, основанных на прослушивании сетевого соединения 
(при условии, что будут использоваться шифрующие средства и сертификат сервера проверен и ему доверяют).
SSL — Secure Socket Layer, уровень защищенных сокетов. TLS — Transport Layer Security, безопасность транспортного уровня. SSL является более ранней системой, TLS появился позднее и он основан на SSL. 
TLS внедрен еще не везде, поэтому, в рамках совместимости, они могут использоваться одновременно.

__Различия _HTTP_ и _HTTPS___:

+ HTTPS является расширением HTTP.

+ HTTP использует не зашифрованное соединение. Соединение по HTTPS поддерживает шифрование.

+ Работа по HTTP быстрей и менее ресурсоёмко, т.к. шифрование HTTPS требует дополнительных затрат.

+ Порты по умолчанию: в случае HTTP это TCP-порт `80`, для HTTPS - TCP-порт `443`.

[к оглавлению](#основы-web)

## Какие есть методы у HTTP?

Метод HTTP (англ. HTTP Method) — указание на основную операцию над ресурсом. Могут быть безопасными (GET, HEAD, OPTIONS, TRACE) и идемпотентными (возвращающими при одинаковом запросе аналогичные результаты, не изменяющими состояние сервера - GET, HEAD, PUT, DELETE, OPTIONS, TRACE).

OPTIONS - используется для получения параметров текущего HTTP соединения, определения возможностей веб-сервера или параметров соединения для конкретного ресурса. Запрос клиента может содержать тело сообщения для указания интересующих его сведений.
Сервер отвечает на запрос с методом OPTIONS только опциями соединения, например он посылает поля заголовков Allow, но не пошлет Content-Type, ответы сервера на запросы с методом OPTIONS не кэшируются. Если в качестве URI указана звездочка «*», то параметры соединения передаются для сервера в целом, а не для какого-то конкретного URL.

GET - используется для получения информации от сервера по заданному URI. Запросы клиентов, использующие метод GET должны получать только данные и не должны никак влиять на эти данные.
С помощью метода GET можно также начать какой-либо процесс. В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса.
Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа «?»: GET /path/resource?param1=value1&param2=value2 HTTP/1.1
Бывает двух видов: условный метод (с if) - для передачи данных, если условия выполняются и частичный метод (с range) - для передачи данных по частям.
HEAD - работает точно так же, как GET, но в ответ сервер посылает только заголовки и статусную строку без тела ответа. Запрос HEAD обычно применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения. Ответы на такие запросы могут кешироваться.

POST - используется для отправки данных на сервер, (формы, которые заполняет посетитель, или файлы для загрузки). Передаваемые данные включаются в тело запроса. При результате выполнения 200 (Ok) в тело ответа включается сообщение об итоге выполнения запроса. Если был создан ресурс, то ответ будет 201 (Created) с указанием URI нового ресурса в заголовке Location. Сообщение ответа сервера на выполнение метода POST не кэшируются, но это можно сделать принудительно, если использовать поле Cache-Control или Expires в заголовке.

PUT - используется для загрузки содержимого запроса на указанный в этом же запросе URI. Заменяет все текущие представления ресурса данными запроса.
Применяется для загрузки содержимого запроса на указанный в запросе URI. Если по заданному URI не существует ресурс, то сервер создаёт его и возвращает статус 201 (Created). Если же был изменён ресурс, то сервер возвращает 200 (Ok) или 204 (No Content). Сервер не должен игнорировать некорректные заголовки Content-*, передаваемые клиентом вместе с сообщением. Если какой-то из этих заголовков не может быть распознан или не допустим при текущих условиях, то необходимо вернуть код ошибки 501 (Not Implemented). Сообщения ответов сервера на метод PUT не кэшируются.
Из rfc2068: Фундаментальное различие между POST и PUT запросами, отражено в различном значении запрашиваемого URI (Request-URI). URI в запросе POST идентифицирует ресурс, который обрабатывает включенный объект. Этим ресурсом может быть процесс, принимающий данные, шлюз к некоторому другому протоколу, или отдельный объект, который принимает аннотации (accepts annotations). Напротив, URI в запросе PUT идентифицирует объект, включенный в запрос - агент пользователя назначает данный URI включенному ресурсу, а сервер НЕ ДОЛЖЕН пытаться применить запрос к некоторому другому ресурсу

PATCH - аналогичен PUT, но применяется только к фрагменту ресурса.

DELETE - удаляет указанный в URI ресурс. Действие метода DELETE может быть отменено вмешательством администратора HTTP сервера или программным кодом. Даже в том случае, когда сервер отправит вам код 200 после обработки метода DELETE, это не будет означать, что ресурс удален, это всего лишь означает, что сервер вас понял и обработал ваш запрос. Ответы сервера на HTTP метод DELETE не кэшируются.

TRACE - используется для получения информации о том, что происходит с сообщением на промежуточных узлах. У сообщений с HTTP методом TRACE есть конечный получатель, который определяется значением поля заголовка Max-Forwards: первый HTTP сервер, прокси-сервер или шлюз, получивший данное сообщение с значением Max-Forwards 0 является конечным получателем. Запросы с HTTP методом TRACE не должны содержать объектов. Ответы сервера на метод TRACE не кэшируются.

CONNECT - преобразует соединение запроса к ресурсу в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси.

[к оглавлению](#основы-web)

## Какие есть группы кодов ответы у HTTP?

В настоящее время выделено пять классов кодов состояния.

Код 1xx Информационный (англ. informational)

Информирование о процессе передачи. Сами сообщения от сервера содержат только стартовую строку ответа и, если требуется, несколько специфичных для ответа полей заголовка.

2xx Успех (англ. Success)

Информирование о случаях успешного принятия и обработки запроса клиента. В зависимости от статуса, сервер может также передать заголовки и тело сообщения.

3xx Перенаправление (англ. Redirection)

Сообщает клиенту, что для успешного выполнения операции необходимо сделать другой запрос (как правило по другому URI). Адрес, по которому клиенту следует произвести запрос, сервер указывает в заголовке Location.

4xx Ошибка клиента (англ. Client Error)

Указание ошибок со стороны клиента. При использовании всех методов, кроме HEAD, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя.

5xx Ошибка сервера (англ. Server Error)

Информирование о случаях неудачного выполнения операции по вине сервера. Для всех ситуаций, кроме использования метода HEAD, сервер должен включать в тело сообщения объяснение, которое клиент отобразит пользователю.

Наиболее популярные коды ответа:

101 Switching Protocols
200 OK ,
301 Moved Permanently,
302 Moved Temporarily
404 Not Found,
403 Forbidden,
500 Internal server Error

[к оглавлению](#основы-web)

## Что такое _FTP_?
__FTP, File Transfer Protocol (Протокол передачи файлов)__ — протокол передачи файлов между компьютерами в сети TCP. С его помощью можно подключаться к FTP-серверам, просматривать содержимое их каталогов и загружать файлы с сервера или на сервер. Протокол построен на архитектуре «клиент-сервер» и использует разные сетевые соединения для передачи команд и данных между клиентом и сервером. 

По умолчанию использует TCP-порт `21`.

[к оглавлению](#основы-web)

## Что такое API?

API (application programming interface, программный интерфейс приложения) - интерфейс, предоставляемый приложением для использования во внешних программных продуктах.
Каждый раз, когда пользователь посещает какую-либо страницу в сети, он взаимодействует с API удалённого сервера. API — это составляющая часть сервера, которая получает запросы и отправляет ответы.
Таким образом, когда компания предлагает своим веб-пользователям API, это просто означает, что она создала ряд специальных URL, которые в качестве ответа возвращают только данные (обычно XML или JSON.
API используется для интеграции с другими сервисами или для автоматизации тестирования.

[к оглавлению](#основы-web)

## Чем отличаются методы _GET_ и _POST_?
__GET__ передает данные серверу используя URL, тогда как __POST__ передает данные, используя тело HTTP запроса. Длина URL ограничена 1024 символами, это и будет верхним ограничением для данных, которые можно отослать через GET. POST может отправлять гораздо большие объемы данных. Лимит устанавливается web-server и составляет обычно около 2 Mb.

Передача данных методом POST более безопасна, чем методом GET, так как секретные данные (например пароль) не отображаются напрямую в web-клиенте пользователя, в отличии от URL, который виден почти всегда. Иногда это преимущество превращается в недостатком - вы не сможете послать данные за кого-то другого.

[к оглавлению](#основы-web)

## Что такое DNS ?
 
DNS (Domain Name System - система доменных имён) - глобальное распределенное хранилище ключей (доменных имен) и значений (ip адресов сайтов).
У DNS-серверов две роли:
⦁ связь между парой "айпи адрес" - "имя сайта"
⦁ дополнительная (но тоже важная) — кэширование записей других DNS-серверов.

Домен — название зоны в системе доменных имён (DNS).
Поддомен — имя подчинённой зоны. (например, avk-company.ru — поддомен домена ru). Теоретически такое деление может достигать глубины 127 уровней, а каждая метка может содержать до 63 символов, пока общая длина вместе с точками не достигнет 254 символов. Но на практике регистраторы доменных имён используют более строгие ограничения.

Выяснять связь между названием сайта и его IP-адресом требуется при каждом обращении к этому веб-сайту. Чтобы избежать задержек, ближайший к вашему компьютеру DNS-сервер (обычно находящийся у вашего интернет-провайдера), сохраняет сведения о ранее запрошенных IP-адресах, и при повторном обращении к тому же сайту он сообщит его адрес очень быстро, так как будет хранить его в своём кэше.
Но чтобы что-то кэшировать, нужно иметь источник кэшируемого. Таким источником служат первичные DNS-сервера, хранящие изначальные связи между доменами и их IP-адресами.
При обращении к доменному имени сервер dns, к которому пришло обращение, проверяет наличие информации в кеше или в своей таблице значений. Если запись не была найдена, обращение переходит на уровень выше (в соответствии с внутренней таблицей сервера) до тех пор, пока запись не будет найдена.

[к оглавлению](#основы-web)

## Что такое _MIME тип_?
__MIME, Multipurpose Internet Mail Extension (Многоцелевые расширения Интернет-почты)__ — спецификация для передачи по сети файлов различного типа: изображений, музыки, текстов, видео, архивов и др. В HTML указание MIME-типа используется при  передаче данных форм и вставки на страницу различных объектов.

[к оглавлению](#основы-web)

## Что такое _Web server_?
__Web server (Веб-сервер)__ — сервер, принимающий HTTP-запросы от клиентов и выдающий им HTTP-ответы. Так называют как программное обеспечение, выполняющее функции web-сервера, так и непосредственно компьютер, на котором это программное обеспечение работает. 

Web-серверы могут иметь различные дополнительные функции, например:

+ автоматизация работы web-страниц;
+ ведение журнала обращений пользователей к ресурсам;
+ аутентификация и авторизация пользователей;
+ поддержка динамически генерируемых страниц;
+ поддержка HTTPS для защищённых соединений с клиентами.

Наиболее известные web-серверы:

+ Apache
+ Microsoft IIS
+ nginx

[к оглавлению](#основы-web)

## Что такое _Web application_?
__Web application (Веб-приложение)__ - клиент-серверное приложение, в котором клиентом выступает браузер, а сервером — web-сервер. Логика web application распределена между сервером и клиентом, хранение данных осуществляется, преимущественно, на сервере, а обмен информацией происходит по сети. Одним из преимуществ такого подхода является тот факт, что клиенты не зависят от конкретной операционной системы пользователя, поэтому web application является кроссплатформенным сервисом.

[к оглавлению](#основы-web)

## Что такое _Application server_?
__Application Server (Сервер приложений)__ — программа, представляющая собой сервер, который занимается системной поддержкой приложений и обеспечивает их жизненный цикл в соответствии с правилами, определёнными в спецификациях. Может работать как полноценный самостоятельный web-сервер или быть поставщиком страниц для другого web-сервера. Обеспечивает обмен данными между приложениями и клиентами, берёт на себя выполнение таких функций, как создание программной среды для функционирующего приложения, идентификацию и авторизацию клиентов, организацию сессии для каждого из них.

Наиболее известные серверы приложений Java:

+ Apache Tomcat
+ Jetty
+ JBoss
+ GlassFish
+ IBM WebSphere
+ Oracle Weblogic

[к оглавлению](#основы-web)

## Чем отличаются _Web server_ и _Application server_?
Понятие web server относится скорее к способу передачи данных (конкретно, по протоколу HTTP), в то время как понятие Application server относится к способу выполнения этих самых приложений (конкретно, удаленная обработка запросов клиентов при помощи каких-то программ, размещенных на сервере). Эти понятия нельзя ставить в один ряд. Они обозначают разные признаки программы. Какие-то программы удовлетворяют только одному признаку, какие-то - нескольким сразу.

Apache Tomcat умеет выполнять приложения? Да, значит он является application server. Apache Tomcat умеет отдавать данные по HTTP? - Да. Следовательно он является web server.

Возьмите какую-нибудь базу данных, в которой на хранимых процедурах описана сложная логика и можно в ответ на SQL-запросы отправлять даже sms. Такую базу данных можно назвать application server, но web server - уже нет, потому что все это не работает с клиентом по HTTP протоколу.

Возьмите чистый Apache, в котором не включены никакие модули для поддержки языков программирования. Он умеет отдавать только статичные файлы и картинки по протоколу HTTP. Это web server, но не application server. Включите модуль для поддержки PHP и разместите там программу на PHP, которая делает запросы к базе данных и динамически формирует страницы. Теперь Apache стал и application server.

[к оглавлению](#основы-web)

## Что такое _AJAX_? Как принципиально устроена эта технология?
__AJAX, Asynchronous Javascript and XML (Асинхронный Javascript и XML)__ — подход к построению интерактивных пользовательских интерфейсов web-приложений, заключающийся в «фоновом» обмене данными браузера и web-сервера. В результате, при обновлении данных web-страница не перезагружается полностью и web-приложения становятся быстрее и удобнее.

При использовании AJAX:

1. Пользователь заходит на web-страницу и взаимодействует с каким-нибудь её элементом.
2. Скрипт на языке JavaScript определяет, какая информация необходима для обновления страницы.
3. Браузер отправляет соответствующий запрос на web-сервер.
4. Web-сервер возвращает только ту часть документа, на которую пришёл запрос.
5. Скрипт вносит изменения с учётом полученной информации (без полной перезагрузки страницы).

AJAX базируется на двух основных принципах:

1. использование технологии динамического обращения к серверу «на лету» (без перезагрузки страницы полностью) через динамическое создание:
    + _дочерних фреймов_;
    + _тега `<script>`_;
    + _тега `<img>`_.
2. использование _DHTML_ для динамического изменения содержания страницы;

AJAX не является самостоятельной технологией, это концепция использования нескольких смежных технологий:

+ _(X)HTML_, _CSS_ для подачи и стилизации информации;
+ _DOM-модель_, операции над которой производятся Javascript на стороне клиента, для обеспечения динамического отображения и взаимодействия с информацией;
+ _XMLHttpRequest_ или другой транспорт (_IFrame_, _SCRIPT-тег_, _..._) для асинхронного обмена данными с web-сервером;
+ _JSON_ или любой другой подходящий формат (_форматированный HTML_, _текст_, _XML_, _..._) для обмена данными.

[к оглавлению](#основы-web)

## Что такое _WebSocket_?
__WebSocket__ — протокол полнодуплексной связи поверх TCP-соединения, предназначенный для обмена сообщениями между браузером и web-сервером в режиме реального времени.

Протокол _WebSocket_ определяет две URI схемы

+ `ws:` - нешифрованное соединение
+ `wss:` - шифрованное соединение

[к оглавлению](#основы-web)

## Что такое _JSON_?
__JSON, JavaScript Object Notation__ — текстовый формат обмена данными, основанный на JavaScript.

JSON представляет собой (в закодированном виде) одну из двух структур:

+ _Набор пар «ключ:значение»_;
+ _Упорядоченный набор значений_.

Ключом может быть только строка (регистрозависимая: имена с буквами в разных регистрах считаются разными).

В качестве значений могут быть использованы:

+ _Объект_ — неупорядоченное множество пар «ключ:значение», заключённое в фигурные скобки `{ }`. Ключ описывается строкой, между ним и значением стоит символ `:`. Пары ключ-значение отделяются друг от друга запятыми;
+ _Массив (одномерный)_ — упорядоченное множество значений. Массив заключается в квадратные скобки `[ ]`. Значения разделяются запятыми.
+ _Число_;
+ _Литералы_ `true`, `false` и `null`;
+ _Строка_ — упорядоченное множество из нуля или более символов Unicode, заключенное в кавычки `" "`. Символы могут быть указаны с использованием escape-последовательностей, начинающихся с обратной косой черты `\`, или записаны шестнадцатеричным кодом в кодировке UTF-8 в виде `\uFFFF`.

[к оглавлению](#основы-web)

## Что такое _JSON схема_?
__JSON Schema__ — один из языков описания структуры JSON-документа, используя синтаксис JSON.

Это самоописательный язык: при его использовании для обработки данных и описания их допустимости могут использоваться одни и те же инструменты сериализации/десериализации.

[к оглавлению](#основы-web)

## Что такое _cookies_?
__Сookies («куки»)__ — небольшой фрагмент данных, отправленный web-сервером и хранимый на устройстве пользователя. Всякий раз при попытке открыть страницу сайта, web-клиент пересылает соответствующие этому сайту cookies web-серверу в составе HTTP-запроса. Применяется для сохранения данных на стороне пользователя и на практике обычно используется для:

+ аутентификации пользователя;
+ хранения персональных предпочтений и настроек пользователя;
+ отслеживания состояния сеанса доступа пользователя;
+ ведения разнообразной статистики.

[к оглавлению](#основы-web)

## Что такое _«сессия»_?
__Сессия__ – промежуток времени между первым и последним запросами, которые пользователь отправляет со своего устройства на сервер сайта. Завершается сессия в случае, если со стороны пользователя не поступало запросов в течение определенного промежутка времени или же при обрыве связи.

[к оглавлению](#основы-web)

## Что такое _«авторизация»_ и _«аутентификация»_? Чем они отличаются?
__Аутентификация__ - это проверка соответствия субъекта и того, за кого он пытается себя выдать, с помощью некой уникальной информации (отпечатки пальцев, цвет радужки, голос и тд.), в простейшем случае - с помощью имени входа и пароля.

__Авторизация__ - это проверка и определение полномочий на выполнение некоторых действий (например, чтение файла) в соответствии с ранее выполненной аутентификацией.

Очевидно, что это разные понятия, но при этом без первого не может быть второго и наоборот. То есть имея разрешение на работу, вы не сможете оказаться на рабочем месте без предъявления пропуска, равно как и нет смысла в демонстрации пропуска, если вы не планируете работать. Именно тот факт, что одного не бывает без другого, и вызывает у людей заблуждение, что это одно и то же.

[к оглавлению](#основы-web)

## Требования к архитектуре REST

Обязательными условиями-ограничениями являются:

`1. Модель клиент-сервер`

Отделение потребности интерфейса клиента от потребностей сервера, хранящего данные, повышает переносимость кода клиентского интерфейса на другие платформы, а упрощение серверной части улучшает масштабируемость. 

`2. Отсутствие состояния`

Протокол взаимодействия между клиентом и сервером требует соблюдения следующего условия: 
в период между запросами клиента никакая информация о состоянии клиента на сервере не хранится (Stateless protocol). 
Все запросы от клиента должны быть составлены так, чтобы сервер получил всю необходимую информацию для выполнения запроса. 
Состояние сессии при этом сохраняется на стороне клиента. Информация о состоянии сессии может быть передана сервером какому-либо другому сервису 
(например, в службу базы данных) для поддержания устойчивого состояния, например, на период установления аутентификации. 
Клиент инициирует отправку запросов, когда он готов (возникает необходимость) перейти в новое состояние.
Во время обработки клиентских запросов считается, что клиент находится в переходном состоянии. 
Каждое отдельное состояние приложения представлено связями, которые могут быть задействованы при следующем обращении клиента.

`3. Кэширование`

Клиенты, а также промежуточные узлы, могут выполнять кэширование ответов сервера. 
Ответы сервера, в свою очередь, должны иметь явное или неявное обозначение как кэшируемые или некэшируемые с целью предотвращения получения клиентами устаревших или неверных данных в ответ на последующие запросы. 
Правильное использование кэширования способно полностью или частично устранить некоторые клиент-серверные взаимодействия, ещё больше повышая производительность и расширяемость системы.

`4. Единообразие интерфейса`

Наличие унифицированного интерфейса является фундаментальным требованием дизайна REST-сервисов. Унифицированные интерфейсы позволяют каждому из сервисов развиваться независимо.

К унифицированным интерфейсам предъявляются следующие четыре ограничительных условия:
 
 - Идентификация ресурсов. Все ресурсы идентифицируются в запросах, например, с использованием URI в интернет-системах. Ресурсы концептуально отделены от представлений, которые возвращаются клиентам. Например, сервер может отсылать данные из базы данных в виде HTML, XML или JSON, ни один из которых не является типом хранения внутри сервера.
 
 - Манипуляция ресурсами через представление. Если клиент хранит представление ресурса, включая метаданные — он обладает достаточной информацией для модификации или удаления ресурса.

 - «Самоописываемые» сообщения. Каждое сообщение содержит достаточно информации, чтобы понять, каким образом его обрабатывать. К примеру, обработчик сообщения (parser), необходимый для извлечения данных, может быть указан в списке MIME-типов[2].

 - Гипермедиа как средство изменения состояния приложения (HATEOAS). Клиенты изменяют состояние системы только через действия, которые динамически определены в гипермедиа на сервере (к примеру, гиперссылки в гипертексте). Исключая простые точки входа в приложение, клиент не может предположить, что доступна какая-то операция над каким-то ресурсом, если не получил информацию об этом в предыдущих запросах к серверу. Не существует универсального формата для предоставления ссылок между ресурсами, RFC 5988 и JSON Hypermedia API Language являются двумя популярными форматами предоставления ссылок в REST HYPERMEDIA сервисах.

`5. Слои`

Клиент обычно не способен точно определить, взаимодействует он напрямую с сервером или же с промежуточным узлом, 
в связи с иерархической структурой сетей (подразумевая, что такая структура образует слои). 
Применение промежуточных серверов способно повысить масштабируемость за счёт балансировки нагрузки и распределённого кэширования. 
Промежуточные узлы также могут подчиняться политике безопасности с целью обеспечения конфиденциальности информации.

`6. Код по требованию (необязательное ограничение)`

REST может позволить расширить функциональность клиента за счёт загрузки кода с сервера в виде апплетов или сценариев. 

[к оглавлению](#основы-web)

## REST и SOAP - что это, в чем разница, какие у каждого плюсы и минусы?

REST (Representational state transfer, передача состояния представления) – это стиль архитектуры программного обеспечения для распределенных систем. Как правило, используется для построения веб-служб.

Особенности архитектурного стиля:
Каждая сущность должна иметь уникальный идентификатор – URI.
Сущности должны быть связаны между собой.
Для чтения и изменения данных должны использоваться стандартные методы ( GET, POST, PUT и DELETE).
Должна быть поддержка нескольких типов ресурсов.
Отсутствие состояния взаимодействий не сохраняет контекст клиента на сервере между запросами

SOAP (от англ. Simple Object Access Protocol — простой протокол доступа к объектам) — протокол обмена структурированными сообщениями в распределённой вычислительной среде. Используется для обмена произвольными сообщениями в формате XML. Главным недостатком SOAP является его сложность по причине гибкости.

Основными характеристиками SOAP являются:

Все передаваемые сообщения кодируются с помощью XML (SOAP messages).
Все SOAP службы имеют описание на языке WSDL, которое тоже является XML-ом. Это позволяет клиентом автоматически сгенерировать прокси классы.
SOAP поддерживает почти все известные протоколы TCP/IP (TCP, UDP, HTTP, SMTP, FTP и т.д.). Именно по этой причине SOAP является довольно сложным протоколом по сравнению с предыдущими.
При использовании HTTP, поддерживается как метод GET так и POST. GET допускается использовать только для получения данных, т.е. на стороне сервера нe должно ничего меняться. POST можно использовать для всех случаев. На практике обычно используется только POST.


Отличия REST и SOAP
В отличие от веб-сервисов (веб-служб) на основе SOAP, не существует «официального» стандарта для RESTful веб-API. Дело в том, что REST является архитектурным стилем, в то время как SOAP является протоколом. Несмотря на то, что REST не является стандартом сам по себе, большинство RESTful-реализаций используют стандарты, такие как HTTP, URL, JSON и XML.

SOAP использует XML и обеспечивает целостность при передаче между клиентом и сервером. С другой стороны, запросы и ответы в REST могут передаваться в ASCII, XML, JSON или любых других форматах, распознаваемых одновременно и клиентом, и сервером. Кроме того, в модели REST отсутствуют встроенные требования к типизации данных. В результате пакеты запросов и ответов в REST имеют намного меньшие размеры, чем соответствующие им пакеты SOAP.
В основе REST лежит концепция ресурсов, в то время как SOAP использует интерфейсы, основанные на объектах и методах. Интерфейс SOAP может содержать практически неограниченное количество методов; интерфейс REST, напротив, ограничен четырьмя возможными операциями, соответствующими четырем методам HTTP.
SOAP используют HTTP как транспортный протокол, в то время как REST базируется на нем. Это означает, что все существующие наработки на базе протокола HTTP, такие как кеширование на уровне сервера, масштабирование, продолжают так же работать в REST архитектуре, а для SOAP необходимо искать другие средства. Взамен этого SOAP сервисы получают такое мифическое свойство, как возможность работать с любым протоколом транспортного уровня вместо HTTP
«REST vs SOAP» можно перефразировать в «Простота vs Стандарты», что проявляется в том, что для SOAP мы имеем протокол WSDL для исчерпывающего описания веб-сервиса, который с использованием все тех же чудесных средств разработки проcто-таки волшебным образом делает почти всю работу за нас. Со стороны REST мы имеем загадочный и неиспользуемый протокол WADL, который, в принципе, и не нужен – он мешает простоте.

[к оглавлению](#основы-web)

## Какие есть методы у REST ?
CRUD методы (create, read, update, delete)
Create = PUT with a new URI POST to a base URI returning a newly created URI
Read = GET
Update = PUT with an existing URI
Delete = DELETE
Стандартные методы таковы:
GET – получение данных без их изменения. Это наиболее популярный и легкий метод. Он только возвращает данные, а не изменяет их, поэтому на клиенте вам не нужно заботиться о том, что вы можете повредить данные.
POST – метод, подразумевающий вставку новых записей. POST запрос наиболее часто используется для создания новых ресурсов. На практике он используется для создания вложенных ресурсов. Другими словами, при создании нового ресурса, POST запрос отправляется к родительскому ресурсу и, таким образом, сервис берет на себя ответственность на установление связи создаваемого ресурса с родительским ресурсом, назначение новому ресурсу ID и т.п.
PUT – метод, подразумевающий изменение существующих записей.
PATCH – метод, подразумевающий изменение идентификатора существующих записей.
DELETE – метод, подразумевающий удаление записей.
Эти же методы (CRUD) есть и в SQL - Select, Insert, Update, Delete.

[к оглавлению](#основы-web)

## Можем ли мы получить данные методом POST?

Нет, метод POST предназначен для отправки данных на сервер согласно спецификации

[к оглавлению](#основы-web)

## Можем ли мы добавить данные методом GET?

Нет, метод GET предназначен для получения данных от сервера согласно спецификации.
В SOAP до версии 1.2 можно было использовать POST, чтобы получить GET. Тем не менее, это не является рекомендуемым поведением

[к оглавлению](#основы-web)

## Является ли метод POST защищенным?

Если пользователь введет в текстовое поле какой-либо текст и нажмет на кнопку «Отправить», то на сервер будет отправлена переменная text со значением того содержимого, которое ввел пользователь. Эта переменная будет отправлена методом POST. Метод POST скрывает все передаваемые им переменные и их значения, в своём теле (Entity-Body). В случае с методом GET они хранились в строке запроса (Request-URI).
Таким образом, передавая данные методом POST, их будет намного труднее перехватить злоумышленнику, т.к. они скрыты от непосредственного просмотра, поэтому метод передачи данных методом POST считается более безопасным способом. Это помогает спрятать передаваемые данные от веб-пауков, обходящих все доступные им ссылки. Тем не менее, метод не является защищенным. Для обеспечения конфиденциальности нужно использовать HTTPS.

[к оглавлению](#основы-web)

## Что такое микросервисы? Чем они отличаются от монолита?

Микросервисы — современное представление сервис-ориентированной архитектуры (SOA), используемое для создания распределенных программных систем.
Архитектурный стиль микросервисов — это подход, при котором единое приложение строится как набор небольших сервисов, каждый из которых работает в собственном процессе и коммуницирует с остальными используя легковесные механизмы, как правило HTTP.
Свойства микросервиса:

Он небольшой.
Он независимый.
Он строится вокруг бизнес-потребности и использует ограниченный контекст (Bounded Context).
Он взаимодействует с другими микросервисами по сети на основе паттерна Smart endpoints and dumb pipes.
Его распределенная суть обязывает использовать подход Design for failure.
Централизация ограничена сверху на минимуме.
Процессы его разработки и поддержки требуют автоматизации.
Его развитие итерационное.

Монолит (monolithic style) - приложение, построенное как единое целое. Enterprise приложения часто включают три основные части: пользовательский интерфейс (состоящий как правило из HTML страниц и javascript-а), база данных (как правило реляционной, со множеством таблиц) и сервер. Серверная часть обрабатывает HTTP запросы, выполняет доменную логику, запрашивает и обновляет данные в БД, заполняет HTML страницы, которые затем отправляются браузеру клиента. Любое изменение в системе приводит к пересборке и развертыванию новой версии серверной части приложения. Вся логика по обработке запросов выполняется в единственном процессе.

Монолит проще при создании, но сложнее в поддержке и масштабировании. Их большой плюс - отсутствие разделения приложения по функциям (это один из самых сложных моментов при переходе к микросервисам).
Микросервисы требуют кросс-платформенных команд, больше затрат на создание, но дают большую масштабируемость, позволяют обновлять приложение по частям, не привязаны к конкретному языку и сбой микросервиса не приводит к сбою всего приложения.

[к оглавлению](#основы-web)

# Источники
+ [Википедия](https://ru.wikipedia.org/)

[Вопросы для собеседования](README.md)
